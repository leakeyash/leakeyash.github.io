<!DOCTYPE html>



  



<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="henry, leakey" />










<meta property="og:type" content="website">
<meta property="og:title" content="leakeyash">
<meta property="og:url" content="https://leakeyash.github.io/index.html">
<meta property="og:site_name" content="leakeyash">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="leakeyash">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"right","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://leakeyash.github.io/"/>





  <title>leakeyash</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-right 
  page-home">
    <div class="headband"></div>
    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">leakeyash</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-something">
          <a href="/something" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-leaf"></i> <br />
            
            试一下
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://leakeyash.github.io/2018/05/20/sort-summary/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Henry Li">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="leakeyash">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/05/20/sort-summary/" itemprop="url">sort-summary</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-05-20T22:04:17+08:00">
                2018-05-20
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://leakeyash.github.io/2018/05/20/radix-sort/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Henry Li">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="leakeyash">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/05/20/radix-sort/" itemprop="url">基数排序</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-05-20T21:26:26+08:00">
                2018-05-20
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/algorithm/" itemprop="url" rel="index">
                    <span itemprop="name">algorithm</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="桶排序（bucket-sort）"><a href="#桶排序（bucket-sort）" class="headerlink" title="桶排序（bucket sort）"></a>桶排序（bucket sort）</h2><p>基本思想:<br>&emsp;&emsp;将阵列分到有限数量的桶子里。每个桶子再个别排序（有可能再使用别的排序算法或是以递回方式继续使用桶排序进行排序）。桶排序是鸽巢排序的一种归纳结果。 当要被排序的阵列内的数值是均匀分配的时候，桶排序使用线性时间（Θ（n））。但桶排序并不是 比较排序，他不受到 O(n log n) 下限的影响。<br>&emsp;&emsp;简单来说，就是把数据分组，放在一个个的桶中，然后对每个桶里面的在进行排序。   </p>
<p>例如要对大小为[1..1000]范围内的n个整数A[1..n]排序：  </p>
<ol>
<li>可以把桶设为大小为10的范围，具体而言，设集合B[1]存储[1..10]的整数，集合B[2]存储(10..20]的整数，……集合B[i]存储((i-1)<em>10, i</em>10]的整数，i= 1,2,..100。总共有100个桶。</li>
<li>对A[1..n]从头到尾扫描一遍，把每个A[i]放入对应的桶B[j]中。 再对这100个桶中每个桶里的数字排序，这时可用冒泡，选择，乃至快排，一般来说任何排序法都可以。</li>
<li>依次输出每个桶里面的数字，且每个桶中的数字从小到大输出，这样就得到所有数字排好序的一个序列了。</li>
</ol>
<p>&emsp;&emsp;假设有n个数字，有m个桶，如果数字是平均分布的，则每个桶里面平均有n/m个数字。如果对每个桶中的数字采用快速排序，那么整个算法的复杂度是<br>   O(n + m<em>n/m</em>  log(n/m)) = O(n + nlogn - nlogm)<br>&emsp;&emsp;从上式看出，当m接近n的时候，桶排序复杂度接近O(n)。<br>&emsp;&emsp;当然，以上复杂度的计算是基于输入的n个数字是平均分布这个假设的。这个假设是很强的  ，实际应用中效果并没有这么好。如果所有的数字都落在同一个桶中，那就退化成一般的排序了。  </p>
<p>&emsp;&emsp;前面说的几大排序算法 ，大部分时间复杂度都是O（n2），也有部分排序算法时间复杂度是O(nlogn)。而桶式排序却能实现O（n）的时间复杂度。但桶排序的缺点是：</p>
<ul>
<li>首先是空间复杂度比较高，需要的额外开销大。排序有两个数组的空间开销，一个存放待排序数组，一个就是所谓的桶，比如待排序值是从0到m-1，那就需要m个桶，这个桶数组就要至少m个空间。</li>
<li>其次待排序的元素都要在一定的范围内等等。</li>
</ul>
<p>&emsp;&emsp;桶式排序是一种分配排序。分配排序的特定是不需要进行关键码的比较，但前提是要知道待排序列的一些具体情况。  </p>
<p>设n个元素的待排序列包含d 个关键码{k1，k2，…，kd}，则称序列对关键码{k1，k2，…，kd}有序是指：<br>对于序列中任两个记录r[i]和r<a href="1≤i≤j≤n">j</a>都满足下列有序关系：<br><img src="../images/radix-sort.jpg" alt="sample"><br>其中k1 称为最主位关键码，kd 称为最次位关键码.</p>
<p><font color="lightblue">两种多关键码排序方法：</font><br>&emsp;&emsp;多关键码排序按照从最主位关键码到最次位关键码或从最次位到最主位关键码的顺序逐次排序，分两种方法：  </p>
<ul>
<li><p><strong>最高位优先(Most Significant Digit first)法</strong>，简称MSD 法：  </p>
<ol>
<li>先按k1 排序分组，将序列分成若干子序列，同一组序列的记录中，关键码k1 相等。</li>
<li>再对各组按k2 排序分成子组，之后，对后面的关键码继续这样的排序分组，直到按最次位关键码kd 对各子组排序后。</li>
<li>再将各组连接起来，便得到一个有序序列。扑克牌按花色、面值排序中介绍的方法一即是MSD 法。  </li>
</ol>
</li>
<li><p><strong>最低位优先(Least Significant Digit first)法</strong>，简称LSD 法：  </p>
<ol>
<li>先从kd 开始排序，再对kd-1进行排序，依次重复，直到按k1排序分组分成最小的子序列后。</li>
<li>最后将各个子序列连接起来，便可得到一个有序的序列, 扑克牌按花色、面值排序中介绍的方法二即是LSD 法。</li>
</ol>
</li>
</ul>
<p><strong>基于LSD方法的链式基数排序的基本思想</strong><br>&emsp;&emsp;“多关键字排序”的思想实现“单关键字排序”。对数字型或字符型的单关键字，可以看作由多个数位或多个字符构成的多关键字，此时可以采用“分配 -收集”的方法进行排序，这一过程称作基数排序法，其中每个数字或字符可能的取值个数称为基数。比如，扑克牌的花色基数为4，面值基数为13。在整理扑克 牌时，既可以先按花色整理，也可以先按面值整理。按花色整理时，先按红、黑、方、花的顺序分成4摞（分配），再按此顺序再叠放在一起（收集），然后按面值 的顺序分成13摞（分配），再按此顺序叠放在一起（收集），如此进行二次分配和收集即可将扑克牌排列有序。</p>
<h2 id="基数排序-radix-sort"><a href="#基数排序-radix-sort" class="headerlink" title="基数排序(radix sort)"></a>基数排序(radix sort)</h2><p>&emsp;&emsp;是按照低位先排序，然后收集；再按照高位排序，然后再收集；依次类推，直到最高位。有时候有些属性是有优先级顺序的，先按低优先级排序，再按高优先级排序。最后的次序就是高优先级高的在前，高优先级相同的低优先级高的在前。基数排序基于分别排序，分别收集，所以是稳定的。</p>
<p>示例代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">public static int[] RadixSort(int[] list)&#123;</span><br><span class="line">    sort(list, 2);</span><br><span class="line">    return list;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private static void sort(int[] list, int d)&#123;//d表示最大的数有多少位</span><br><span class="line">    int k =0;</span><br><span class="line">    int n =1;</span><br><span class="line">    int m =1;//控制键值排序依据在哪一位</span><br><span class="line">    var temp = new int[10,list.Length];//数组的第一维表示可能的余数0-9</span><br><span class="line">    var order = new int[10];//数组orderp[i]用来表示该位是i的数的个数</span><br><span class="line">    while(m&lt;=d)&#123;</span><br><span class="line">        //循环将数组中的值放入到相应的桶temp[lsd]中</span><br><span class="line">        for(int i = 0; i &lt; list.Length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            int lsd = ((list[i] / n) % 10);</span><br><span class="line">            temp[lsd, order[lsd]] = list[i];</span><br><span class="line">            order[lsd]++;</span><br><span class="line">        &#125;</span><br><span class="line">        //将temp中的值给回list，最低位优先LSD</span><br><span class="line">        for(int i = 0; i &lt; 10; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            if(order[i] != 0)</span><br><span class="line">                for(int j = 0; j &lt; order[i]; j++)</span><br><span class="line">                &#123;</span><br><span class="line">                    list[k] = temp[i,j];</span><br><span class="line">                    k++;</span><br><span class="line">                &#125;</span><br><span class="line">            order[i] = 0;</span><br><span class="line">        &#125;</span><br><span class="line">        n *= 10;</span><br><span class="line">        k = 0;</span><br><span class="line">        m++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://leakeyash.github.io/2018/05/03/merge-sort/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Henry Li">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="leakeyash">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/05/03/merge-sort/" itemprop="url">归并排序</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-05-03T22:36:12+08:00">
                2018-05-03
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/algorithm/" itemprop="url" rel="index">
                    <span itemprop="name">algorithm</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="归并排序（bubble-sort）"><a href="#归并排序（bubble-sort）" class="headerlink" title="归并排序（bubble sort）"></a>归并排序（bubble sort）</h2><p>基本思想:<br>&emsp;&emsp;归并（Merge）排序法是将两个（或两个以上）有序表合并成一个新的有序表，即把待排序序列分为若干个子序列，每个子序列是有序的。然后再把有序子序列合并为整体有序序列。<br>冒泡排序的示例：<br><img src="../images/merge-sort.jpg" alt="sample"><br>示例代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">public static int[] NormalMergeSort(int[] list)&#123;</span><br><span class="line">    var result = new int[list.Length];</span><br><span class="line">    // 初始提取间隔为1</span><br><span class="line">    int interval = 1;</span><br><span class="line">    while(interval &lt; list.Length)&#123;</span><br><span class="line">        int length = interval;</span><br><span class="line">        interval = 2 * interval;</span><br><span class="line">        int i = 0;</span><br><span class="line">        // 每隔一定的间隔提取相邻2个序列进行归并</span><br><span class="line">        while(i+interval&lt;list.Length)&#123;</span><br><span class="line">            Merge(list,result,i,i+length-1,i+interval-1);</span><br><span class="line">            i += interval;</span><br><span class="line">        &#125;</span><br><span class="line">        // 对于最后一组不够元素个数的序列进行归并</span><br><span class="line">        if(i+length&lt;=list.Length)&#123;</span><br><span class="line">            Merge(list,result,i,i+length-1,list.Length-1);</span><br><span class="line">        &#125;</span><br><span class="line">        // 交换list 和 result，避免空间浪费</span><br><span class="line">        var tmp = list;</span><br><span class="line">        list = result;</span><br><span class="line">        result = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br><span class="line">private static void Merge(int[] list,int[] result, int left, int mid, int right)&#123;</span><br><span class="line">    int j,k;</span><br><span class="line">    //原数组list 分为2部分,left...mid,mid+1...right,循环2部分的元素，按顺序存入result数组中。</span><br><span class="line">    for(j=mid+1,k=left;left&lt;=mid&amp;&amp;j&lt;=right;++k)&#123;</span><br><span class="line">        if(list[j]&lt;list[left])&#123;</span><br><span class="line">            result[k] = list[j++];</span><br><span class="line">        &#125;</span><br><span class="line">        else&#123;</span><br><span class="line">            result[k]=list[left++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //右边数组已经排完了，把其余左边的全加入进来即可。</span><br><span class="line">    while(left&lt;=mid)&#123;</span><br><span class="line">        result[k++] = list[left++];</span><br><span class="line">    &#125;</span><br><span class="line">    while(j&lt;=right)&#123;</span><br><span class="line">        result[k++] = list[j++];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>两路归并排序：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">public static int[] TwoSidesMergeSort(int[] list)&#123;</span><br><span class="line">    var result = new int[list.Length];</span><br><span class="line">    int n =1;</span><br><span class="line">    while(n&lt;list.Length)&#123;</span><br><span class="line">        MergePass(list,result,n);</span><br><span class="line">        n*=2;</span><br><span class="line">        if(n&lt;list.Length)&#123;</span><br><span class="line">            MergePass(result,list,n);</span><br><span class="line">            n*=2;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return list;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private static void MergePass(int[] list, int[] result, int length)&#123;</span><br><span class="line">    for(int i=0;i&lt;list.Length;i+=2*length)&#123;</span><br><span class="line">        Merge(list,result,i,i+length,length);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">private static void Merge(int[] list, int[] result, int begin1, int begin2, int length)&#123;</span><br><span class="line">    int i = begin1, j = begin2, k = begin1;</span><br><span class="line">    while(i&lt;begin1+length&amp;&amp;j&lt;begin2+length&amp;&amp;j&lt;list.Length)&#123;</span><br><span class="line">        if(list[i]&lt;list[j])&#123;</span><br><span class="line">            result[k++]=list[i++];</span><br><span class="line">        &#125;</span><br><span class="line">        else&#123;</span><br><span class="line">            result[k++]=list[j++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    while(i&lt;begin1+length&amp;&amp;i&lt;list.Length)&#123;</span><br><span class="line">        result[k++] = list[i++];</span><br><span class="line">    &#125;</span><br><span class="line">    while(j&lt;begin2+length&amp;&amp;j&lt;list.Length)&#123;</span><br><span class="line">        result[k++] = list[j++];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://leakeyash.github.io/2018/04/25/exchange-sort/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Henry Li">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="leakeyash">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/04/25/exchange-sort/" itemprop="url">交换排序</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-04-25T23:00:14+08:00">
                2018-04-25
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/algorithm/" itemprop="url" rel="index">
                    <span itemprop="name">algorithm</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="冒泡排序（bubble-sort）"><a href="#冒泡排序（bubble-sort）" class="headerlink" title="冒泡排序（bubble sort）"></a>冒泡排序（bubble sort）</h2><p>基本思想:<br>&emsp;&emsp;在要排序的一组数中，对当前还未排好序的范围内的全部数，自上而下对相邻的两个数依次进行比较和调整，让较大的数往下沉，较小的往上冒。即：每当两相邻的数比较后发现它们的排序与排序要求相反时，就将它们互换。<br>冒泡排序的示例：<br><img src="../images/bubble-sort.jpg" alt="sample"><br>示例代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public static int[] SimpleBubbleSort(int[] list)&#123;</span><br><span class="line">    var length = list?.Length;</span><br><span class="line">    if(length&lt;=1) return list;</span><br><span class="line">    for(var i=0;i&lt;length;i++)&#123;</span><br><span class="line">        //从第0个元素开始，到倒数第二个元素，依次对比冒泡。</span><br><span class="line">        for(var j=0;j&lt;length-1-i;j++)&#123;</span><br><span class="line">            if(list[j]&gt;list[j+1])&#123;</span><br><span class="line">            var temp = list[j];</span><br><span class="line">            list[j]=list[j+1];</span><br><span class="line">            list[j+1]=temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;          </span><br><span class="line">    &#125;</span><br><span class="line">    return list;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<hr>
<h2 id="冒泡排序的常用改进（bubble-sort）"><a href="#冒泡排序的常用改进（bubble-sort）" class="headerlink" title="冒泡排序的常用改进（bubble sort）"></a>冒泡排序的常用改进（bubble sort）</h2><h3 id="设置标志变量"><a href="#设置标志变量" class="headerlink" title="设置标志变量"></a>设置标志变量</h3><p>&emsp;&emsp;设置一标志性变量pos,用于记录每趟排序中最后一次进行交换的位置。由于pos位置之后的记录均已交换到位,故在进行下一趟排序时只要扫描到pos位置即可。<br>改进后算法如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public static int[] BubbleWithFlagSort(int[] list)&#123;</span><br><span class="line">    var length = list?.Length;</span><br><span class="line">    if(length&lt;=1) return list;</span><br><span class="line">    int i = (int)length-1;</span><br><span class="line">    while(i&gt;0)&#123;</span><br><span class="line">        int pos = 0;</span><br><span class="line">        for(var j=0;j&lt;i;j++)&#123;</span><br><span class="line">            if(list[j]&gt;list[j+1])&#123;</span><br><span class="line">                pos = j;</span><br><span class="line">                var temp = list[j];</span><br><span class="line">                list[j]=list[j+1];</span><br><span class="line">                list[j+1]=temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        i = pos;</span><br><span class="line">    &#125;       </span><br><span class="line">    return list;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="同时取最大值和最小值"><a href="#同时取最大值和最小值" class="headerlink" title="同时取最大值和最小值"></a>同时取最大值和最小值</h3><p>&emsp;&emsp;传统冒泡排序中每一趟排序操作只能找到一个最大值或最小值,我们考虑利用在每趟排序中进行正向和反向两遍冒泡的方法一次可以得到两个最终值(最大者和最小者) , 从而使排序趟数几乎减少了一半。<br>改进后的算法实现为:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public static int[] BubbleTwoSidesSort(int[] list)&#123;</span><br><span class="line">    var length = list?.Length;</span><br><span class="line">    if(length&lt;=1) return list;</span><br><span class="line">    int low =0;</span><br><span class="line">    int high = (int)length-1;</span><br><span class="line">    while(low&lt;high)&#123;           </span><br><span class="line">        for(var j=low;j&lt;high;j++)&#123;</span><br><span class="line">            if(list[j]&gt;list[j+1])&#123;</span><br><span class="line">                var temp = list[j];</span><br><span class="line">                list[j]=list[j+1];</span><br><span class="line">                list[j+1]=temp;</span><br><span class="line">            &#125;                             </span><br><span class="line">        &#125;</span><br><span class="line">        high--;</span><br><span class="line">        for(var j=high;j&gt;low;j--)&#123;</span><br><span class="line">            if(list[j]&lt;list[j-1])&#123;</span><br><span class="line">                var temp = list[j];</span><br><span class="line">                list[j]=list[j-1];</span><br><span class="line">                list[j-1]=temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        low++;</span><br><span class="line">    &#125;       </span><br><span class="line">    return list;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<hr>
<h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><p>基本思想:  </p>
<ol>
<li>选择一个基准元素,通常选择第一个元素或者最后一个元素,</li>
<li>通过一趟排序讲待排序的记录分割成独立的两部分，其中一部分记录的元素值均比基准元素值小。另一部分记录的 元素值比基准值大。</li>
<li>此时基准元素在其排好序后的正确位置</li>
<li>然后分别对这两部分记录用同样的方法继续进行排序，直到整个序列有序。  </li>
</ol>
<p>快速排序的示例： </p>
<ul>
<li>一趟排序的过程：<br><img src="../images/quick-sort-1.jpg" alt="sample">  </li>
<li>排序的全过程：<br><img src="../images/quick-sort-2.jpg" alt="sample"> </li>
</ul>
<p>示例代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">public static int[] QuickSort(int[] list)&#123;</span><br><span class="line">    var length = list?.Length;</span><br><span class="line">    if(length&lt;=1) return list;</span><br><span class="line">    QuickSort(list,0,(int)length-1);</span><br><span class="line">    return list;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private static void QuickSort(int[] list, int low, int high)&#123;</span><br><span class="line">    if(low&lt;high)&#123;</span><br><span class="line">        int privotIndex = Partition(list, low, high);</span><br><span class="line">        QuickSort(list, low, privotIndex -1);</span><br><span class="line">        QuickSort(list, privotIndex+1, high);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">private static int Partition(int[] list,int low,int high)&#123;</span><br><span class="line">    var pivot = list[low];</span><br><span class="line">    while(low&lt;high)&#123;</span><br><span class="line">        //从高到低，跳过本来就比标的值大的</span><br><span class="line">        while(low&lt;high&amp;&amp;list[high]&gt;=pivot) high--;</span><br><span class="line">        //交换比标的值小的</span><br><span class="line">        var temp1 = list[low];</span><br><span class="line">        list[low]=list[high];</span><br><span class="line">        list[high]=temp1;</span><br><span class="line">        //从低到高，跳过本来就比标的值小的</span><br><span class="line">        while(low&lt;high&amp;&amp;list[low]&lt;=pivot) low++;</span><br><span class="line">        //交换比标的大的</span><br><span class="line">        var temp2 = list[low];</span><br><span class="line">        list[low]=list[high];</span><br><span class="line">        list[high]=temp2;</span><br><span class="line">    &#125;</span><br><span class="line">    return low;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>分析：<br>快速排序是通常被认为在同数量级（O(nlog2n)）的排序方法中平均性能最好的。但若初始序列按关键码有序或基本有序时，快排序反而蜕化为冒泡排序。为改进之，通常以“三者取中法”来选取基准记录，即将排序区间的两个端点与中点三个记录关键码居中的调整为支点记录。快速排序是一个不稳定的排序方法。</p>
<h3 id="快速排序的改进"><a href="#快速排序的改进" class="headerlink" title="快速排序的改进"></a>快速排序的改进</h3><p>&emsp;&emsp;在本改进算法中,只对长度大于k的子序列递归调用快速排序,让原序列基本有序，然后再对整个基本有序序列用插入排序算法排序。实践证明，改进后的算法时间复杂度有所降低，且当k取值为 8 左右时,改进算法的性能最佳。<br>示例代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">public static int[] ImprovedQuickSort(int[] list)&#123;</span><br><span class="line">    var length = list?.Length;</span><br><span class="line">    if(length&lt;=1) return list;</span><br><span class="line">    //对子序列大于8个元素时才进行快速排序,实验证明8的时候性能最佳</span><br><span class="line">    QuickSort(list,0,(int)length-1,8);</span><br><span class="line">    //对快速排序后的序列进行插入排序</span><br><span class="line">    for(var i=1;i&lt;length;i++)&#123;</span><br><span class="line">        int tmp = list[i];</span><br><span class="line">        int j = i-1;</span><br><span class="line">        while(j&gt;=0&amp;&amp;tmp&lt;list[j])&#123;</span><br><span class="line">            list[j+1]=list[j];</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">        list[j+1] = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    return list;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private static void QuickSort(int[] list, int low, int high, int k)&#123;</span><br><span class="line">    if(high - low &gt; k)&#123;</span><br><span class="line">        int privotIndex = Partition(list, low, high);</span><br><span class="line">        QuickSort(list, low, privotIndex -1);</span><br><span class="line">        QuickSort(list, privotIndex+1, high);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">private static int Partition(int[] list,int low,int high)&#123;</span><br><span class="line">    var pivot = list[low];</span><br><span class="line">    while(low&lt;high)&#123;</span><br><span class="line">        //从高到低，跳过本来就比标的值大的</span><br><span class="line">        while(low&lt;high&amp;&amp;list[high]&gt;=pivot) high--;</span><br><span class="line">        //交换比标的值小的</span><br><span class="line">        var temp1 = list[low];</span><br><span class="line">        list[low]=list[high];</span><br><span class="line">        list[high]=temp1;</span><br><span class="line">        //从低到高，跳过本来就比标的值小的</span><br><span class="line">        while(low&lt;high&amp;&amp;list[low]&lt;=pivot) low++;</span><br><span class="line">        //交换比标的大的</span><br><span class="line">        var temp2 = list[low];</span><br><span class="line">        list[low]=list[high];</span><br><span class="line">        list[high]=temp2;</span><br><span class="line">    &#125;</span><br><span class="line">    return low;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://leakeyash.github.io/2018/04/11/slection-sort/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Henry Li">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="leakeyash">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/04/11/slection-sort/" itemprop="url">选择排序</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-04-11T20:55:10+08:00">
                2018-04-11
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/algorithm/" itemprop="url" rel="index">
                    <span itemprop="name">algorithm</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="简单选择排序（simple-selection-sort）"><a href="#简单选择排序（simple-selection-sort）" class="headerlink" title="简单选择排序（simple selection sort）"></a>简单选择排序（simple selection sort）</h2><p>基本思想:<br>&emsp;&emsp;在要排序的一组数中，选出最小（或者最大）的一个数与第1个位置的数交换；然后在剩下的数当中再找最小（或者最大）的与第2个位置的数交换，依次类推，直到第n-1个元素（倒数第二个数）和第n个元素（最后一个数）比较为止。</p>
<p>排序示例<br>4,6,3,2,7,1,5,8,9    </p>
<ol>
<li>1 6 3 2 7 4 5 8 9</li>
<li>1 2 3 6 7 4 5 8 9</li>
<li>1 2 3 4 7 6 5 8 9</li>
<li>1 2 3 4 5 6 7 8 9</li>
</ol>
<p>代码示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public static int[] SimpleSelectionSort(int[] list)&#123;</span><br><span class="line">    if(list.Length&lt;=1) return list;</span><br><span class="line">    for(var i=0;i&lt;list.Length;i++)&#123;</span><br><span class="line">        var index = i;</span><br><span class="line">        var minKeyIndex = i;</span><br><span class="line">        var temp = list[i];</span><br><span class="line">        var j = i;</span><br><span class="line">        while(j&lt;list.Length)&#123;</span><br><span class="line">            if(list[j]&lt;temp)&#123;</span><br><span class="line">                minKeyIndex = j;</span><br><span class="line">                temp = list[j];</span><br><span class="line">            &#125;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        if(minKeyIndex!=i)&#123;</span><br><span class="line">            var t = list[i];</span><br><span class="line">            list[i] = list[minKeyIndex];</span><br><span class="line">            list[minKeyIndex] = t;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return list;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<hr>
<h2 id="二元选择排序（binary-selection-sort）"><a href="#二元选择排序（binary-selection-sort）" class="headerlink" title="二元选择排序（binary selection sort）"></a>二元选择排序（binary selection sort）</h2><p>基本思想:<br>&emsp;&emsp;简单选择排序，每趟循环只能确定一个元素排序后的定位。我们可以考虑改进为每趟循环确定两个元素（当前趟最大和最小记录）的位置,从而减少排序所需的循环次数。改进后对n个数据进行排序，最多只需进行[n/2]趟循环即可。<br>代码示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">public static int[] BinarySelectionSort(int[] list)&#123;</span><br><span class="line">    var length = list.Length;</span><br><span class="line">    if(length&lt;=1) return list;</span><br><span class="line">    for(var i=0;i&lt;=length/2;i++)&#123;</span><br><span class="line">        var min = i;</span><br><span class="line">        var max = length - i -1;</span><br><span class="line"></span><br><span class="line">        for(var j=i+1;j&lt;length-i;j++)&#123;</span><br><span class="line">            if(list[j]&lt;list[min])&#123;</span><br><span class="line">                min = j;</span><br><span class="line">            &#125;</span><br><span class="line">            else if(list[j]&gt;list[max])&#123;</span><br><span class="line">                max = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if(min!=i)&#123;</span><br><span class="line">            var t = list[i];</span><br><span class="line">            list[i] = list[min];</span><br><span class="line">            list[min] = t;</span><br><span class="line">        &#125;</span><br><span class="line">        if(max!=length-i-1)&#123;</span><br><span class="line">            var t = list[length-i-1];</span><br><span class="line">            list[length-i-1] = list[max];</span><br><span class="line">            list[max] = t;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return list;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<hr>
<h2 id="堆排序（heap-sort）"><a href="#堆排序（heap-sort）" class="headerlink" title="堆排序（heap sort）"></a>堆排序（heap sort）</h2><p>堆排序是一种树形选择排序，是对直接选择排序的有效改进。<br>基本思想:<br>&emsp;&emsp;简单选择排序，每趟循环只能确定一个元素排序后的定位。我们可以考虑改进为每趟循环确定两个元素（当前趟最大和最小记录）的位置,从而减少排序所需的循环次数。改进后对n个数据进行排序，最多只需进行[n/2]趟循环即可。<br>堆的定义如下：<br>具有n个元素的序列（k1,k2,…,kn),当且仅当满足:</p>
<ul>
<li>k<sub>i</sub> &le; k<sub>2i</sub></li>
<li>k<sub>i</sub> &le; k<sub>2i+1</sub><br>或者</li>
<li>k<sub>i</sub> &ge; k<sub>2i</sub></li>
<li>k<sub>i</sub> &ge; k<sub>2i+1</sub><br>(i=1,2,3…&lfloor;n/2&rfloor;)  </li>
</ul>
<p>时称之为堆。<br>&emsp;&emsp;由堆的定义可以看出，堆顶元素（即第一个元素）必为最小项（小顶堆）。<br>&emsp;&emsp;若以一维数组存储一个堆，则堆对应一棵完全二叉树，且所有非叶结点的值均不大于(或不小于)其子女的值，根结点（堆顶元素）的值是最小(或最大)的。<br>如：  </p>
<ul>
<li>(a)大顶堆序列：（96, 83,27,38,11,09)  </li>
<li>(b)小顶堆序列：（12，36，24，85，47，30，53，91）<br><img src="../images/heap-sort.jpg" alt="sample">  </li>
</ul>
<p>&emsp;&emsp;初始时把要排序的n个数的序列看作是一棵顺序存储的二叉树（一维数组存储二叉树）， 调整它们的存储顺序，使之成为一个堆，将堆顶元素输出，得到n个元素中最小(或最大)的元素，这时堆的根节点的数最小（或者最大）。然后对前面(n-1)个元素重新调整使之成为堆，输出堆顶元素，得到n个元素中次小(或次大)的元素。依此类推，直到只有两个节点的堆，并对它们作交换，最后得到有n个节点的有序序列。称这个过程为<strong>堆排序</strong>。  </p>
<p>因此，实现堆排序需解决两个问题：</p>
<ol>
<li>如何将n 个待排序的数建成堆；</li>
<li>输出堆顶元素后，怎样调整剩余n-1 个元素，使其成为一个新堆。</li>
</ol>
<p>&emsp;&emsp;首先讨论第二个问题：输出堆顶元素后，对剩余n-1元素重新建成堆的调整过程。<br>调整小顶堆的方法：  </p>
<ol>
<li>设有m 个元素的堆，输出堆顶元素后，剩下m-1 个元素。将堆底元素送入堆顶（（最后一个元素与堆顶进行交换），堆被破坏，其原因仅是根结点不满足堆的性质。</li>
<li>将根结点与左、右子树中较小元素的进行交换。</li>
<li>若与左子树交换：如果左子树堆被破坏，即左子树的根结点不满足堆的性质，则重复方法 2</li>
<li>若与右子树交换，如果右子树堆被破坏，即右子树的根结点不满足堆的性质。则重复方法 2</li>
<li>继续对不满足堆性质的子树进行上述交换操作，直到叶子结点，堆被建成。  </li>
</ol>
<p>称这个自根结点到叶子结点的调整过程为筛选。如图：<br><img src="../images/heap-sort-1.jpg" alt="sample"> </p>
<p>再讨论对n 个元素初始建堆的过程。  </p>
<p>建堆方法：对初始序列建堆的过程，就是一个反复进行筛选的过程。  </p>
<ol>
<li>n 个结点的完全二叉树，则最后一个结点是第&lfloor;n/2&rfloor;个结点的子树。</li>
<li>筛选从第&lfloor;n/2&rfloor;个结点为根的子树开始，该子树成为堆。</li>
<li>之后向前依次对各结点为根的子树进行筛选，使之成为堆，直到根结点。<br>如图建堆初始过程：<br><img src="../images/heap-sort-2.jpg" alt="sample"><br>无序序列：（49，38，65，97，76，13，27，49）</li>
</ol>
<p>示例代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">public static int[] HeapSort(int[] list)&#123;</span><br><span class="line">    var length = list.Length;</span><br><span class="line">    if(length&lt;=1) return list;</span><br><span class="line">    //首先建立一个堆，堆顶为数组中最大的元素</span><br><span class="line">    //依据2*(index+1)&lt;=length =&gt; index &lt;= length/2 - 1 </span><br><span class="line">    for(var i= length/2 -1 ;i&gt;=0;i--)&#123;</span><br><span class="line">        HeapConstruct(list,i,length);</span><br><span class="line">    &#125;</span><br><span class="line">    //倒序循环，对换堆顶到队尾，依次构造堆。</span><br><span class="line">    for(var i =length-1;i&gt;0;i--)&#123;</span><br><span class="line">        var temp = list[i];</span><br><span class="line">        list[i] = list[0];</span><br><span class="line">        list[0] = temp;</span><br><span class="line">        HeapConstruct(list,0,i);</span><br><span class="line">    &#125;</span><br><span class="line">    return list;</span><br><span class="line">&#125;</span><br><span class="line">private static void HeapConstruct(int[] list,int startIndex, int length)&#123;</span><br><span class="line">    </span><br><span class="line">    var currentIndex = startIndex;</span><br><span class="line">    var temp = list[currentIndex];</span><br><span class="line">    var leftChildIndex = (currentIndex+1)*2 -1;</span><br><span class="line">    </span><br><span class="line">    //循环找到左儿子是否还在值的范围内</span><br><span class="line">    while(leftChildIndex&lt;length)&#123;</span><br><span class="line">        var biggerChild = leftChildIndex;</span><br><span class="line">        var rightChildIndex = leftChildIndex+1;</span><br><span class="line">        if(rightChildIndex &lt; length &amp;&amp; list[rightChildIndex]&gt; list[leftChildIndex])&#123;</span><br><span class="line">            biggerChild = rightChildIndex;</span><br><span class="line">        &#125;</span><br><span class="line">        if(temp &lt; list[biggerChild])&#123;               </span><br><span class="line">            //如果比较大的子节点比自己大，那么互换节点的值。</span><br><span class="line">            list[currentIndex] = list[biggerChild];</span><br><span class="line">            list[biggerChild] = temp;</span><br><span class="line">            //当前节点指向较大的那个子节点</span><br><span class="line">            currentIndex = biggerChild;</span><br><span class="line">            //找到较大子节点的左儿子</span><br><span class="line">            leftChildIndex = (biggerChild+1)*2-1;</span><br><span class="line">            temp =list[currentIndex];    </span><br><span class="line">        &#125;</span><br><span class="line">        else&#123;    </span><br><span class="line">            //如果当前节点比儿子节点都大则终止循环           </span><br><span class="line">            break;</span><br><span class="line">        &#125;      </span><br><span class="line">    &#125;        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>效率：  </p>
<p>设树深度为k，<br>k = &lfloor;log<sub>2</sub>n&rfloor; +1<br>。从根到叶的筛选，元素比较次数至多2(k-1)次，交换记录至多k 次。所以，在建好堆后，排序过程中的筛选次数不超过下式:<br>2(&lfloor;log<sub>2</sub>(n-1)&rfloor; + &lfloor;log<sub>2</sub>(n-2)&rfloor; + …… + &lfloor;log<sub>2</sub>2&rfloor;) &lt; 2n(&lfloor;log<sub>2</sub>n&rfloor;)<br>而建堆时的比较次数不超过4n 次，因此堆排序最坏情况下，时间复杂度也为：O(nlogn)。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://leakeyash.github.io/2018/04/10/insertion-sort/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Henry Li">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="leakeyash">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/04/10/insertion-sort/" itemprop="url">插入排序</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-04-10T22:11:53+08:00">
                2018-04-10
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/algorithm/" itemprop="url" rel="index">
                    <span itemprop="name">algorithm</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="直接插入排序（straight-insert-sort）"><a href="#直接插入排序（straight-insert-sort）" class="headerlink" title="直接插入排序（straight insert sort）"></a>直接插入排序（straight insert sort）</h2><p>基本思想:<br>&emsp;&emsp;将一个记录插入到已排序好的有序表中，从而得到一个新，记录数增1的有序表。即：先将序列的第1个记录看成是一个有序的子序列，然后从第2个记录逐个进行插入，直至整个序列有序为止。<br>要点：设立哨兵，作为临时存储和判断数组边界之用。<br>直接插入排序示例：<br><img src="../images/staight_insertion_sort.jpg" alt="sample"><br>&emsp;&emsp;如果碰见一个和插入元素相等的，那么插入元素把想插入的元素放在相等元素的后面。所以，相等元素的前后顺序没有改变，从原无序序列出去的顺序就是排好序后的顺序，所以插入排序是<strong>稳定</strong>的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">示例代码：</span><br><span class="line"></span><br><span class="line">public static int[] InsertSort(int[] list)&#123;</span><br><span class="line">    if(list.Length&lt;=1) return list;</span><br><span class="line">    for(var i=1;i&lt;list.Length;i++)&#123;</span><br><span class="line">        if(list[i]&lt;list[i-1])&#123;</span><br><span class="line">            var temp = list[i];</span><br><span class="line">            var j = i-1;</span><br><span class="line">            while(j&gt;=0 &amp;&amp; temp&lt;list[j])&#123;</span><br><span class="line">                list[j+1]= list[j];</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">            list[j+1]=temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return list;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度：O(n^2）。</p>
<hr>
<h2 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h2><p>基本思想:<br>&emsp;&emsp;改进的直接插入算法。设待排序的元素序列有n个元素，首先取一整数gap（&lt;n）作为间隔，将全部元素分为gap个子序列，所有距离为gap的元素放在同一序列中，在每个子序列中分别进行直接插入排序。然后缩小gap，例如<code>gap=gap/2</code>,重复上述的子序列划分与排序工作。开始由于gap取值大，每个子序列元素少，排序速度快，待排序后期，gap值逐渐变小，子序列元素变多，但由于前面的工作基础，大多数元素已经有序，所以排序速度快。<br>&emsp;&emsp;希尔排序是一种不稳定的排序。 </p>
<p>排序示例<br>4,6,3,2,7,1,5,8,9  （gap = 9/2 =4）  </p>
<ol>
<li>(4,7) - (6,1) - (3,5) - (2,8) - 9</li>
<li>4 1 3 2 7 6 5 8 gap=2</li>
<li>(4,3,7,5) - (1,2,6,8)</li>
<li>3 1 4 2 5 6 7 8 gap=1</li>
<li>1 2 3 4 5 6 7 8</li>
</ol>
<p>示例代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public static int[] ShellSort(int[] list)&#123;</span><br><span class="line">    int length = list.Length;</span><br><span class="line">    if(length&lt;=1) return list;</span><br><span class="line">    int gap = length/2;</span><br><span class="line">    while(gap&gt;=1)&#123;</span><br><span class="line">        for(var i=gap;i&lt;length;i++)&#123;</span><br><span class="line">            if(list[i]&lt;list[i-gap])&#123;</span><br><span class="line">                var temp = list[i];</span><br><span class="line">                var j = i-gap;</span><br><span class="line">                while(j&gt;=0&amp;&amp;temp&lt;list[j])&#123;</span><br><span class="line">                    list[j+gap] = list[j];</span><br><span class="line">                    j=j-gap;</span><br><span class="line">                &#125;</span><br><span class="line">                list[j+gap]=temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        gap = gap/2;</span><br><span class="line">    &#125;</span><br><span class="line">    return list;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;希尔排序时效分析很难，关键码的比较次数与记录移动次数依赖于增量因子序列d的选取，特定情况下可以准确估算出关键码的比较次数和记录的移动次数。目前还没有人给出选取最好的增量因子序列的方法。增量因子序列可以有各种取法，有取奇数的，也有取质数的，但需要注意：增量因子中除1外没有公因子，且最后一个增量因子必须为1。</p>
<hr>
<h2 id="二分插入排序（binary-insert-sort）"><a href="#二分插入排序（binary-insert-sort）" class="headerlink" title="二分插入排序（binary insert sort）"></a>二分插入排序（binary insert sort）</h2><p>基本思想:<br>&emsp;&emsp;设在数据表中有一个元素序列v[0],v[1],v[2]……v[n].其中v[0],v[1],v[2]……v[i-1]是已经排好序的元素。在插入v[i]。利用折半搜索寻找v[i]的插入位置。<br>&emsp;&emsp;二分插入排序是一种稳定的排序。当n较大时，总排序码比较次数比直接插入排序的最差情况好得多，但比最好情况要差，所元素初始序列已经按排序码接近有序时，直接插入排序比二分插入排序比较次数少。二分插入排序元素移动次数与直接插入排序相同，依赖于元素初始序列。<br>实现逻辑：<br>&emsp;&emsp;先跟序列最中间的那个元素比较，如果比最中间的这个元素小，则插入位置在它的左边，否则在它的右边。<br>&emsp;&emsp;以当前最中间位置为分割点，如果在左边，则当前最中间位置是待搜索子序列的终点，如果在右边，右边邻接的元素将是待搜索子序列的起点。<br>&emsp;&emsp;按照这种原则，继续寻找下一个中间位置，并继续这种过程，直到找到合适的插入位置为止。  </p>
<p>示例代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public static int[] BinaryInsertSort(int[] list)&#123;</span><br><span class="line">    int length = list.Length;</span><br><span class="line">    if(length&lt;=1) return list;</span><br><span class="line">    for(var i=1;i&lt;length;i++)&#123;</span><br><span class="line">        var temp = list[i];</span><br><span class="line">        var head = 0;</span><br><span class="line">        var tail = i-1;</span><br><span class="line">        while(head&lt;=tail)&#123;</span><br><span class="line">            var mid = (head+tail)/2;</span><br><span class="line">            if(temp&lt; list[mid])&#123;</span><br><span class="line">                tail = mid - 1;</span><br><span class="line">            &#125;</span><br><span class="line">            else&#123;</span><br><span class="line">                head = mid +1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        for(var j = i-1;j&gt;=head;j--)&#123;</span><br><span class="line">            list[j+1]=list[j];</span><br><span class="line">        &#125;</span><br><span class="line">        list[head] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    return list;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>最坏的情况下二分插入排序的时间复杂度依然是O(n^2)。<br>如果待排序的序列已经有序，排序时间复杂度为O(nlogn)。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://leakeyash.github.io/2018/04/10/sort-brief/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Henry Li">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="leakeyash">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/04/10/sort-brief/" itemprop="url">排序算法简介</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-04-10T21:48:06+08:00">
                2018-04-10
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/algorithm/" itemprop="url" rel="index">
                    <span itemprop="name">algorithm</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>&emsp;&emsp;排序有内部排序和外部排序，内部排序是数据记录在内存中进行排序，而外部排序是因排序的数据很大，一次不能容纳全部的排序记录，在排序过程中需要访问外存。</p>
<h4 id="外部排序"><a href="#外部排序" class="headerlink" title="外部排序"></a>外部排序</h4><p>&emsp;&emsp;一般来说外排序分为两个步骤：预处理和合并排序。首先，根据可用内存的大小，将外存上含有n个纪录的文件分成若干长度为t的子文件（或段）；其次，利用内部排序的方法，对每个子文件的t个纪录进行内部排序。这些经过排序的子文件（段）通常称为顺串(run)，顺串生成后即将其写入外存。这样在外存上就得到了m个顺串（m=[n/t]）。最后，对这些顺串进行归并，使顺串的长度逐渐增大，直到所有的待排序的几率成为一个顺串为止。</p>
<h4 id="内部排序"><a href="#内部排序" class="headerlink" title="内部排序"></a>内部排序</h4><ul>
<li>插入排序<ul>
<li>直接插入排序</li>
<li>希尔排序</li>
</ul>
</li>
<li>选择排序<ul>
<li>简单选择排序</li>
<li>堆排序</li>
</ul>
</li>
<li>交换排序<ul>
<li>冒泡排序</li>
<li>快速排序</li>
</ul>
</li>
<li>归并排序</li>
<li>基数排序</li>
</ul>
<p>&emsp;&emsp;当n较大，则应采用时间复杂度为O(nlog2n)的排序方法：快速排序、堆排序或归并排序序。<br>&emsp;&emsp;<font color="lightblue">快速排序是目前基于比较的内部排序中被认为是最好的方法，当待排序的关键字是随机分布时，快速排序的平均时间最短。</font></p>
<p>参考代码：<br><a href="https://github.com/leakeyash/dotnetcore-sample/tree/master/algorithm" target="_blank" rel="noopener">https://github.com/leakeyash/dotnetcore-sample/tree/master/algorithm</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://leakeyash.github.io/2018/04/05/first-blog/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Henry Li">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="leakeyash">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/04/05/first-blog/" itemprop="url">从一段简单算法题来谈二叉查找树(BST)的基础算法</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-04-05T18:21:42+08:00">
                2018-04-05
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/algorithm/" itemprop="url" rel="index">
                    <span itemprop="name">algorithm</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>先给出一道很简单，喜闻乐见的二叉树算法题：</p>
<p>给出一个二叉查找树和一个目标值，如果其中有两个元素的和等于目标值则返回真，否则返回假。</p>
<p>例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Input:  </span><br><span class="line">    5  </span><br><span class="line">   / \  </span><br><span class="line">  3   6  </span><br><span class="line"> / \   \  </span><br><span class="line">2   4   7</span><br></pre></td></tr></table></figure></p>
<p>Target = 9</p>
<p>Output: True<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Input: </span><br><span class="line">    5</span><br><span class="line">   / \</span><br><span class="line">  3   6</span><br><span class="line"> / \   \</span><br><span class="line">2   4   7</span><br></pre></td></tr></table></figure></p>
<p>Target = 28</p>
<p>Output: False
　</p>
<h3 id="什么是二叉树？"><a href="#什么是二叉树？" class="headerlink" title="什么是二叉树？"></a>什么是二叉树？</h3><p>二叉树是每个节点最多有两个子树的树结构。  </p>
<hr>
<h3 id="什么是二叉查找树（binary-search-tree）"><a href="#什么是二叉查找树（binary-search-tree）" class="headerlink" title="什么是二叉查找树（binary search tree）"></a>什么是二叉查找树（binary search tree）</h3><p>二叉排序树或者是一棵空树，或者是具有下列性质的二叉树：</p>
<ul>
<li>若左子树不空，则左子树上所有结点的值均小于或等于它的根结点的值；</li>
<li>若右子树不空，则右子树上所有结点的值均大于或等于它的根结点的值；</li>
<li>左、右子树也分别为二叉排序树；</li>
</ul>
<hr>
<h3 id="二叉树的遍历"><a href="#二叉树的遍历" class="headerlink" title="二叉树的遍历"></a>二叉树的遍历</h3><ul>
<li><p><strong>先序遍历(pre-order)</strong><br>　　首先访问根结点然后遍历左子树，最后遍历右子树。在遍历左、右子树时，仍然先访问根结点，然后遍历左子树，最后遍历右子树，如果二叉树为空则返回。</p>
</li>
<li><p><strong>后序遍历((post-order)</strong><br>　　后序遍历首先遍历左子树，然后遍历右子树，最后访问根结点，在遍历左、右子树时，仍然先遍历左子树，然后遍历右子树，最后遍历根结点。</p>
</li>
<li><p><strong>中序遍历(in-order)</strong><br>　　中序遍历首先遍历左子树，然后访问根节点，然后遍历右子树。  </p>
</li>
</ul>
<hr>
<p>举个例子：<br><img src="../images/sample1.png" alt="sample"><br>先序遍历节点遍历顺序： A B D H I K E C F G J L<br>后序遍历节点遍历顺序： H K I D E B F L J G C A<br>中序遍历节点遍历顺序： H D I K B E A F C J L G    </p>
<hr>
<h2 id="算法题解法"><a href="#算法题解法" class="headerlink" title="算法题解法"></a>算法题解法</h2><ol>
<li><h4 id="使用HashSet"><a href="#使用HashSet" class="headerlink" title="使用HashSet"></a>使用HashSet</h4>　　最简单的解法就是遍历整个树，然后得到所有的节点对来判断他们是否能相加得到目标值k。但是我们稍微考虑一下缓存，这个方案还能提高一些。<br>　　如果两个元素的和等于k，即x+y=k，并且我们已经知道x是已经存在于树的，我们只要检索y是否也在树的节点里即可，即y=k-x。基于这个简单的缓存，我们可以在每一步去遍历这棵树的两个方向（左子树和右子树）。我们使用一个集合来存遍历过程中被遍历过的元素。<br>　　对于每一个当前的节点，有值p，我们去检查k-p是否存在于集合中。如果存在的话，我们可以得到存在2个元素的值等于k的结论。否则，我们继续把这个值存进集合。<br>　　如果遍历了整棵树后，没有这样的p值，那就证明不存在2个元素的值相加等于k。<br>　　代码如下：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class Solution &#123;</span><br><span class="line">    public boolean findTarget(TreeNode root, int k) &#123;</span><br><span class="line">        Set&lt;Integer&gt; set = new HashSet();</span><br><span class="line">        return find(root, k, set);</span><br><span class="line">    &#125;</span><br><span class="line">    public boolean find(TreeNode root, int k, Set &lt; Integer &gt; set) &#123;</span><br><span class="line">        if (root == null)</span><br><span class="line">            return false;</span><br><span class="line">        if (set.contains(k - root.val))</span><br><span class="line">            return true;</span><br><span class="line">        set.add(root.val);</span><br><span class="line">        return find(root.left, k, set) || find(root.right, k, set);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>时间复杂度为 O(n)，空间复杂度也为O(n).</p>
<ol start="2">
<li><h4 id="使用BFS和HashSet"><a href="#使用BFS和HashSet" class="headerlink" title="使用BFS和HashSet."></a>使用BFS和HashSet.</h4></li>
</ol>
<p>在这个解法中，使用HashSet的想法和解法1是一样的。但是我们在遍历的时候使用广度优先算法（Breadth First Search），这是一个在树的遍历算法中很常用的算法。BFS的方法如如下总结的一样。我们在开始的时候把根节点放进一个队列。<br>我们还是会用到如上解法的一个集合。然后在每一步我们会这么做：  </p>
<ol>
<li>从队列queue的头部去除一个元素p。</li>
<li>判断k-p是否存在于集合中。如果是，返回true。</li>
<li>否则，把这个元素p加到集合中。然后，把这个节点的左右子节点加到队列queue的末尾。</li>
<li>继续1-3步骤，直到队列为空。</li>
<li>如果队列为空，则返回false。  </li>
</ol>
<p>照这个步骤，我们一层一层的循环了整个树。<br>代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public class Solution &#123;</span><br><span class="line">    public boolean findTarget(TreeNode root, int k) &#123;</span><br><span class="line">        Set&lt;Integer&gt; set = new HashSet();</span><br><span class="line">        Queue&lt;TreeNode&gt; queue = new LinkedList();</span><br><span class="line">        queue.add(root);</span><br><span class="line">        while (!queue.isEmpty()) &#123;</span><br><span class="line">            if (queue.peek() != null) &#123;</span><br><span class="line">                TreeNode node = queue.remove();</span><br><span class="line">                if (set.contains(k - node.val))</span><br><span class="line">                    return true;</span><br><span class="line">                set.add(node.val);</span><br><span class="line">                queue.add(node.right);</span><br><span class="line">                queue.add(node.left);</span><br><span class="line">            &#125; else</span><br><span class="line">                queue.remove();</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>时间复杂度为 O(n)，空间复杂度也为O(n).</p>
<ol start="3">
<li><h4 id="使用BST"><a href="#使用BST" class="headerlink" title="使用BST"></a>使用BST</h4></li>
</ol>
<p>在这个解法中，我们要充分利用这个树是一个二叉搜索树，现在，我们知道一个树的中序遍历会得到一个递增的节点集。如此一来，我们可以对这棵树进行中序排序，然后把结果存进一个数组，这个数组的元素按照升序的顺序排列。<br>上面的步骤做好以后，我们使用l和r两个指针指向数组的开头和结尾。然后，我们这么做：</p>
<ol>
<li>判断l和r指向的节点的值的和是否等于k。如果是，立马返回true。</li>
<li>如果他们的和小于k，l移向下一个元素。我们需要得到更大的和，那我们只有提高我们更小的那个值。</li>
<li>如果他们的和大于k，r移向上一个元素。我们需要得到更小的和，那我们只有减少我们更大的那个值。</li>
<li>循环执行1-3步，直到l和r指针相遇。</li>
<li>如果l和r指针相遇，则返回false.
　<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public class Solution &#123;</span><br><span class="line">    public boolean findTarget(TreeNode root, int k) &#123;</span><br><span class="line">        List&lt;Integer&gt; list = new ArrayList();</span><br><span class="line">        inorder(root, list);</span><br><span class="line">        int l = 0, r = list.size() - 1;</span><br><span class="line">        while (l &lt; r) &#123;</span><br><span class="line">            int sum = list.get(l) + list.get(r);</span><br><span class="line">            if (sum == k)</span><br><span class="line">                return true;</span><br><span class="line">            if (sum &lt; k)</span><br><span class="line">                l++;</span><br><span class="line">            else</span><br><span class="line">                r--;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    public void inorder(TreeNode root, List &lt; Integer &gt; list) &#123;</span><br><span class="line">        if (root == null)</span><br><span class="line">            return;</span><br><span class="line">        inorder(root.left, list);</span><br><span class="line">        list.add(root.val);</span><br><span class="line">        inorder(root.right, list);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>时间复杂度为 O(n)，空间复杂度也为O(n).</p>
<p>至于广度优先算法和深度优先算法，以后有机会再展开吧。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://leakeyash.github.io/2018/04/05/hello-world/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Henry Li">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="leakeyash">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/04/05/hello-world/" itemprop="url">Hello World</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-04-05T18:06:51+08:00">
                2018-04-05
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="我来到了这个世界。"><a href="#我来到了这个世界。" class="headerlink" title="我来到了这个世界。"></a>我来到了这个世界。</h1><h3 id="于是世界光亮了起来"><a href="#于是世界光亮了起来" class="headerlink" title="于是世界光亮了起来"></a>于是世界光亮了起来</h3>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  


          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/avatar.jpg"
                alt="Henry Li" />
            
              <p class="site-author-name" itemprop="name">Henry Li</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">9</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                
                  <span class="site-state-item-count">1</span>
                  <span class="site-state-item-name">分类</span>
                
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">3</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/leakeyash" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:leakeyash@163.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-spinner"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Henry Li</span>

  
</div>


  <div class="powered-by">
  <i class="fa fa-user-md"></i><span id="busuanzi_container_site_uv">
  本站访客数:<span id="busuanzi_value_site_uv"></span>
  </span>
  </div>



  <span class="post-meta-divider">|  愿星空永远绚烂</span>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  
<script>
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>


  
  

  

  

  

</body>
</html>
<script type="text/javascript" src="/js/src/love.js"></script>
